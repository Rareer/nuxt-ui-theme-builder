#!/usr/bin/env node
/**
 * Scrape Nuxt UI docs props table.
 * Usage:
 *   node scripts/scrape-nuxt-ui-props.mjs <URL|targets.json> [--out path/to/output.json] [--outDir dir]
 *
 * Behavior:
 * - Finds the first <h3 id="props"> heading, then the next table element.
 * - Parses rows as: { name, type }.
 * - Writes JSON array to stdout or to --out file.
 */

import fs from 'node:fs/promises'
import path from 'node:path'
import process from 'node:process'
import { fileURLToPath } from 'node:url'
import { load } from 'cheerio'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Helpers (top-level)
function pascalCase(s) {
  return String(s)
    .split(/[-_\s]/)
    .filter(Boolean)
    .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
    .join('')
}

function deriveKeyFromUrl(url) {
  return (url.split('?')[0].replace(/\/$/, '').split('/').pop() || 'component')
}

function emitTsModule(map) {
  // map: { [componentNameLower]: { url, props } }
  const entries = Object.entries(map)
    .map(([k, v]) => [pascalCase(k), v.props])
    .sort((a, b) => a[0].localeCompare(b[0]))

  const body = entries
    .map(([name, props]) => `  ${name}: ${JSON.stringify(props, null, 2).replace(/\n/g, '\n  ')}`)
    .join(',\n')

  return `// Auto-generated by scrape-nuxt-ui-props.mjs\n// Centralized Nuxt UI docs props dataset\n\nexport type DocsProp = {\n  name: string;\n  type: 'boolean' | 'string' | string[] | unknown;\n};\n\nexport type DocsPropsData = Record<string, DocsProp[]>;\n\nconst data: DocsPropsData = {\n${body}\n};\n\nexport default data;\n`
}

function parseArgs(argv) {
  const args = [...argv]
  const input = args.shift()
  let out = null
  let outDir = null
  while (args.length) {
    const a = args.shift()
    if (a === '--out') out = args.shift() || null
    else if (a === '--outDir') outDir = args.shift() || null
  }

  return { input, out, outDir }
}

function usage() {
  console.error('Usage: node scripts/scrape-nuxt-ui-props.mjs <URL|targets.json> [--out output.(json|ts)] [--outDir dir]')
}

async function main() {
  const [, , ...rest] = process.argv
  const { input, out, outDir } = parseArgs(rest)
  if (!input) {
    usage()
    process.exit(1)
  }

  async function fetchHtml(url) {
    const res = await fetch(url)
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`)
    return await res.text()
  }

  function extractProps(html) {
    const $ = load(html)
    const heading = $('h2#props, h3#props, [id="props"]').first()
    if (!heading.length) return []

    // Find the first table that appears after the heading in DOM order
    const allNodes = $('*')
    const headingIdx = allNodes.index(heading)
    let table = null
    $('table').each((_, el) => {
      if (table) return
      const idx = allNodes.index(el)
      if (idx > headingIdx) table = $(el)
    })
    if (!table) return []

    // Rows: support with/without tbody
    const rows = table.find('tbody tr').length ? table.find('tbody tr') : table.find('tr').slice(1) // skip header if present
    const props = []
    rows.each((_, tr) => {
      const $tr = $(tr)
      const tds = $tr.find('td')
      if (!tds.length) return

      const clean = (s) => s.replace(/\u00A0/g, ' ').replace(/\s+/g, ' ').trim()

      // Name is first column; prefer <code> content
      let name = $(tds[0]).find('code').first().text()
      if (!name) name = $(tds[0]).text()
      name = clean(name)

      // Type extraction: only consider the FIRST <code class="material-theme"> token
      const typeCell = $(tds[tds.length - 1])
      const firstToken = typeCell.find('code.material-theme').first().text()
      const first = clean(firstToken)

      // Determine canonical type from FIRST token only (strict)
      // valid if:
      //  - exactly 'boolean'
      //  - exactly 'string'
      //  - union of quoted string literals: 'a' | "b" | 'c'
      let canonical = null
      const isBoolean = /^\s*boolean\s*$/i.test(first)
      const isStringOnly = /^\s*string\s*$/i.test(first)
      const isStringLiteralUnion = /^\s*(?:'(?:[^']+)'|"(?:[^"]+)")(?:\s*\|\s*(?:'(?:[^']+)'|"(?:[^"]+)"))*\s*$/.test(first)

      if (isBoolean) canonical = 'boolean'
      else if (isStringOnly) canonical = 'string'
      else if (isStringLiteralUnion) {
        const literals = (first.match(/'(?:[^']+)'|"(?:[^"]+)"/g) || [])
          .map(m => m.replace(/^['\"]/,'').replace(/['\"]$/,''))
        canonical = [...new Set(literals)]
      }

      // Keep only when valid; special handling for 'ui'
      if (!name) return
      const valid = canonical === 'boolean' || canonical === 'string' || Array.isArray(canonical)
      if (name === 'ui') {
        // Try to extract keys directly from the type cell (object-like signature)
        const uiKeysFromType = extractUiKeysFromTypeCell(typeCell.text())
        const uiKeys = uiKeysFromType.length ? uiKeysFromType : extractUiKeys($)
        props.push({ name, type: { values: uiKeys } })
      } else {
        if (!valid) return
        // Normalize output type (boolean | string | string[])
        let outType = canonical
        if (Array.isArray(outType)) {
          // unique & stable
          outType = [...new Set(outType)]
        }
        props.push({ name, type: outType })
      }
    })
    return props
  }

  // Heuristic: find a 'ui' section and parse likely keys from code/pre or inline code tokens
  function extractUiKeys($) {
    const keys = new Set()
    // Search for a heading with id 'ui'
    const uiHeading = $('h2#ui, h3#ui, [id="ui"]').first()
    if (uiHeading.length) {
      // Collect code blocks and inline code following the heading up to the next heading
      const allNodes = $('*')
      const startIdx = allNodes.index(uiHeading)
      const nextHeadingIdx = (() => {
        let idx = allNodes.length
        $('h1, h2, h3, h4, h5, h6').each((_, el) => {
          const i = allNodes.index(el)
          if (i > startIdx && i < idx) idx = i
        })
        return idx
      })()
      allNodes.each((i, el) => {
        if (i <= startIdx || i >= nextHeadingIdx) return
        const $el = $(el)
        if (el.tagName === 'code' || el.tagName === 'pre') {
          const text = $el.text()
          // Extract object-like keys and quoted keys
          for (const m of text.matchAll(/['"]([a-zA-Z0-9_-]+)['"]\s*:/g)) keys.add(m[1])
          for (const m of text.matchAll(/\b([a-zA-Z][a-zA-Z0-9_-]{1,})\s*:/g)) keys.add(m[1])
          for (const m of text.matchAll(/class\s*:\s*['"][^'"]+['"]/g)) keys.add('class')
        }
      })
    }
    return Array.from(keys).sort()
  }

  // Parse object-like type cell text to extract keys within braces, e.g.
  // "{ content?: ClassNameValue; arrow?: ClassNameValue; text?: ClassNameValue }"
  function extractUiKeysFromTypeCell(text) {
    const keys = new Set()
    if (!text) return []
    // Get substring within first {...}
    const m = text.match(/\{([\s\S]*?)\}/)
    const body = m ? m[1] : text
    // Match patterns like: key?:, key: , 'key'?:, "key":
    for (const mm of body.matchAll(/['"]?([a-zA-Z_][a-zA-Z0-9_-]*)['"]?\s*\?*\s*:/g)) {
      const k = mm[1]
      if (k && k !== 'class') keys.add(k)
    }
    // Commonly present class key
    if (/\bclass\s*:\s*/.test(body)) keys.add('class')
    return Array.from(keys).sort()
  }

  const isUrl = /^https?:\/\//i.test(input)
  if (isUrl) {
    try {
      const html = await fetchHtml(input)
      const props = extractProps(html)
      const key = deriveKeyFromUrl(input)
      if (out && /\.ts$/i.test(out)) {
        const ts = emitTsModule({ [key]: { url: input, props } })
        const outPath = path.isAbsolute(out) ? out : path.join(process.cwd(), out)
        await fs.mkdir(path.dirname(outPath), { recursive: true })
        await fs.writeFile(outPath, ts, 'utf8')
        console.log(`Wrote TS dataset with 1 component -> ${outPath}`)
      } else {
        const json = JSON.stringify(props, null, 2)
        if (out) {
          const outPath = path.isAbsolute(out) ? out : path.join(process.cwd(), out)
          await fs.mkdir(path.dirname(outPath), { recursive: true })
          await fs.writeFile(outPath, json, 'utf8')
          console.log(`Wrote ${props.length} props to ${outPath}`)
        } else {
          console.log(json)
        }
      }
    } catch (err) {
      console.error('Failed:', err.message)
      process.exit(1)
    }
    return
  }

  // Batch mode: read a JSON file with an array of URLs
  const targetsPath = path.isAbsolute(input) ? input : path.join(process.cwd(), input)
  let targets
  try {
    const raw = await fs.readFile(targetsPath, 'utf8')
    targets = JSON.parse(raw)
  } catch (err) {
    console.error('Failed to read/parse targets file:', err.message)
    process.exit(1)
  }
  if (!Array.isArray(targets)) {
    console.error('Targets JSON must be an array of URLs')
    process.exit(1)
  }

  const results = {}
  for (const url of targets) {
    if (typeof url !== 'string' || !/^https?:\/\//i.test(url)) continue
    try {
      const html = await fetchHtml(url)
      const props = extractProps(html)
      const key = deriveKeyFromUrl(url)
      results[key] = { url, props }
      if (outDir) {
        const dir = path.isAbsolute(outDir) ? outDir : path.join(process.cwd(), outDir)
        await fs.mkdir(dir, { recursive: true })
        const filePath = path.join(dir, `${key}.json`)
        await fs.writeFile(filePath, JSON.stringify(props, null, 2), 'utf8')
        console.log(`Wrote ${props.length} props for ${key} -> ${filePath}`)
      }
    } catch (err) {
      console.error(`Error scraping ${url}:`, err.message)
    }
  }

  if (!outDir) {
    if (out && /\.ts$/i.test(out)) {
      const ts = emitTsModule(results)
      const outPath = path.isAbsolute(out) ? out : path.join(process.cwd(), out)
      await fs.mkdir(path.dirname(outPath), { recursive: true })
      await fs.writeFile(outPath, ts, 'utf8')
      console.log(`Wrote TS dataset for ${Object.keys(results).length} components -> ${outPath}`)
    } else {
      const json = JSON.stringify(results, null, 2)
      if (out) {
        const outPath = path.isAbsolute(out) ? out : path.join(process.cwd(), out)
        await fs.mkdir(path.dirname(outPath), { recursive: true })
        await fs.writeFile(outPath, json, 'utf8')
        console.log(`Wrote aggregated results for ${Object.keys(results).length} components -> ${outPath}`)
      } else {
        console.log(json)
      }
    }
  }
}

main().catch((err) => {
  console.error(err)
  process.exit(99)
})
