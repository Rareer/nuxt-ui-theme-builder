import { defineEventHandler, readBody, getHeader } from 'h3';
import { z } from 'zod';
import { generateObject } from 'ai';
import { createOpenAI } from '@ai-sdk/openai';

// Zod schema reflecting ThemeImportPayload
const ShadeSchema = z.enum(['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', '950']);

const ColorSchema = z.object({
	name: z.string().min(1),
	values: z.object({
		50: z.string(),
		100: z.string(),
		200: z.string(),
		300: z.string(),
		400: z.string(),
		500: z.string(),
		600: z.string(),
		700: z.string(),
		800: z.string(),
		900: z.string(),
		950: z.string(),
	}),
});

const ThemeVariableSchema = z.enum(['primary', 'secondary', 'success', 'info', 'warning', 'error']);

const CssVariableMappingSchema = z.object({
	name: z.string().min(1).regex(/^[a-z0-9-]+$/, 'use kebab-case without leading --'),
	type: z.enum(['color-reference', 'direct-value']),
	value: z.string().min(1),
	label: z.string().default(''),
	category: z.string().default('General'),
	selectedColor: z.string().optional().nullable(),
});

const ThemeImportPayloadSchema = z.object({
	// let CSS be optional but allow AI to omit
	css: z.string().optional(),
	colors: z.array(ColorSchema).optional().default([]),
	themeMappings: z.object({
		primary: z.string().nullable().optional(),
		secondary: z.string().nullable().optional(),
		success: z.string().nullable().optional(),
		info: z.string().nullable().optional(),
		warning: z.string().nullable().optional(),
		error: z.string().nullable().optional(),
	}).optional().default({}),
	// Dark mode variable mappings (same shape as themeMappings)
	themeMappingsDark: z.object({
		primary: z.string().nullable().optional(),
		secondary: z.string().nullable().optional(),
		success: z.string().nullable().optional(),
		info: z.string().nullable().optional(),
		warning: z.string().nullable().optional(),
		error: z.string().nullable().optional(),
	}).optional().default({}),
	cssVariables: z.array(CssVariableMappingSchema).optional().default([]),
	componentsConfig: z.unknown().optional(), // not generated by AI for now
	merge: z.boolean().optional().default(true),
});

type ThemeImportPayload = z.infer<typeof ThemeImportPayloadSchema>;

const systemPrompt = `You are an expert UI designer and design system engineer.
Task: Given a short brief, design a cohesive theme for both LIGHT and DARK modes.
Output strictly as a JSON object that matches the provided response_format schema.

Rules:
- Generate a compact but complete color palette with shades 50..950 for each color.
- Use accessible contrast and harmonious scales.
- Colors must be named in kebab-case (e.g., "ocean-blue", "neutral").
- Note the semantic meaning of the colors for info, warning and error and use appropriate colors here (e.g., a red color for error, an amber for warning).
- Provide variable mappings for BOTH modes:
  - themeMappings: base color names for LIGHT mode (primary, secondary, success, info, warning, error).
  - themeMappingsDark: base color names for DARK mode that are explicitly intended for DARK UIs and are color-schematically consistent with the LIGHT scheme.
- IMPORTANT: Only produce theme variables (colors array, themeMappings, themeMappingsDark). Do NOT generate CSS, other CSS variables, or component configs.
- Set css to an empty string or omit it. Set cssVariables to an empty array []. Omit componentsConfig.
- Do not include comments or extra fields. Only valid JSON matching the schema.`;

export default defineEventHandler(async (event) => {
	try {
		const body = await readBody<{ prompt?: string; model?: string }>(event);
		const userPrompt = (body?.prompt || '').toString().slice(0, 4000);
		const modelName = body?.model || 'gpt-4o-mini';

		if (!userPrompt) {
			return { error: 'Missing prompt' };
		}

		// Initialize provider (use header key if provided, else env)
		const headerKey = getHeader(event, 'x-openai-key') || '';
		const apiKey = headerKey || process.env.OPENAI_API_KEY;
		if (!apiKey) {
			return { error: 'Missing OpenAI API key. Provide one in the modal or set OPENAI_API_KEY on the server.' };
		}
		const openai = createOpenAI({ apiKey });

		const { object } = await generateObject({
			model: openai(modelName),
			system: systemPrompt,
			prompt: userPrompt,
			// Constrain the response to our schema
			schema: ThemeImportPayloadSchema,
			temperature: 0.7,
		});

		// Ensure final validation
		const parsed = ThemeImportPayloadSchema.parse(object);

		// Normalize color names and css variable names server-side
		const normalizeName = (s: string) => s.toLowerCase().trim().replace(/\s+/g, '-').replace(/^--/, '');

		const colorsArr = Array.isArray(parsed.colors) ? parsed.colors : [];
		parsed.colors = colorsArr.map(c => ({
			name: normalizeName(c.name),
			values: c.values,
		}));

		if (parsed.themeMappings) {
			const entries = Object.entries(parsed.themeMappings) as Array<[keyof NonNullable<typeof parsed.themeMappings>, string | null]>;
			parsed.themeMappings = Object.fromEntries(
				entries.map(([k, v]) => [k, v ? normalizeName(v) : null]),
			) as any;
		}

		if (parsed.themeMappingsDark) {
			const entries = Object.entries(parsed.themeMappingsDark) as Array<[keyof NonNullable<typeof parsed.themeMappingsDark>, string | null]>;
			parsed.themeMappingsDark = Object.fromEntries(
				entries.map(([k, v]) => [k, v ? normalizeName(v) : null]),
			) as any;
		}

		// Enforce: Only return theme variables (colors + themeMappings). Strip other fields.
		parsed.css = undefined as any;
		parsed.componentsConfig = undefined as any;
		parsed.cssVariables = [];

		return { data: parsed };
	}
	catch (e: any) {
		return { error: e?.message || 'AI generation failed' };
	}
});
